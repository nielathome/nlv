<!--
Copyright (C) Niel Clausen 2020. All rights reserved.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program. If not, see <https://www.gnu.org/licenses/>.
-->
<!DOCTYPE html>
<meta charset="utf-8">

<!-- Load d3.js -->
<script src="polyfill.8.1.3.js"></script>
<script src="fetch.umd.3.0.0.js"></script>
<script src="d3.v5.min.js"></script>

<!-- Create a div where the graph will take place -->
<div id="my_dataviz"></div>


<style>
    .links line {
        stroke: #aaa;
    }

    .nodes circle {
        stroke: #fff;
        stroke-width: 1.5px;
        pointer-events: all;
    }

    .nodes text {
        font-family: sans-serif;
        font-size: x-small;
        pointer-events: none;
    }
</style>


<script>
    //----------------------------------------------------------
    var g_node_id = 0

    function SetNodeId(node_id) {
        g_node_id = node_id;
    }


    //----------------------------------------------------------

    // retained data
    var g_data = null;
    var g_title_text = null;

    var g_simulation = null;
    var g_curZoom = 0;
    var g_curTransform = d3.zoomIdentity;

    // append the svg object to the body of the page
    var g_svg = d3.select("#my_dataviz").append("svg");

    var g_joined_links = null;
    var g_links_group = g_svg.append("g")
        .attr("class", "links");

    var g_joined_nodes = null;
    var g_joined_labels = null;
    var g_nodes_group = g_svg.append("g")
        .attr("class", "nodes");

    const g_scale = d3.scaleOrdinal(d3.schemeCategory10);


    //----------------------------------------------------------

    // selection support
    var g_has_selection = false;
    var g_selected_nodes = new Set();
    var g_selected_links = new Set();

    function GetNodeOpacity(id) {
        return (!g_has_selection || g_selected_nodes.has(id)) ? 1.0 : 0.5;
    }

    function GetLinkOpacity(id) {
        return (!g_has_selection || g_selected_links.has(id)) ? 1.0 : 0.5;
    }


    //----------------------------------------------------------
    function GetWindowWidth() {
        const min_window = 300, margin = 30;
        return Math.max(min_window, document.documentElement.clientWidth);
    }

    function GetWindowHeight() {
        const min_window = 300, margin = 30;
        return Math.max(min_window, document.documentElement.clientHeight);
    }


    //----------------------------------------------------------
    function Layout() {
        const doTransition = (g_curZoom != g_curTransform.k);
        g_curZoom = g_curTransform.k;

        const ref_transition = d3.transition()
            .duration(250);

        (doTransition ? g_joined_links.transition(ref_transition) : g_joined_links)
            // map model coord system to SVG coord system
            .attr("x1", function (link) {
                return g_curTransform.applyX(link.source.x);
            })
            .attr("y1", function (link) {
                return g_curTransform.applyY(link.source.y);
            })
            .attr("x2", function (link) {
                return g_curTransform.applyX(link.target.x);
            })
            .attr("y2", function (link) {
                return g_curTransform.applyY(link.target.y);
            });

        function translate(item) {
            // map model coord system to SVG coord system
            const x = g_curTransform.applyX(item.x);
            const y = g_curTransform.applyY(item.y);
            return "translate(" + x + "," + y + ")";
        }

        (doTransition ? g_joined_nodes.transition(ref_transition) : g_joined_nodes)
            .attr("transform", translate);

        (doTransition ? g_joined_labels.transition(ref_transition) : g_joined_labels)
            .attr("transform", translate);
    }


    function DoCreateChart() {
        g_curZoom = g_curTransform.k;

        g_svg
            .attr("width", GetWindowWidth())
            .attr("height", GetWindowHeight())
            .call(d3.zoom()
                .scaleExtent([1, 8])
                .wheelDelta(function wheelDelta() {
                    // d3.event here is the underlying WheelEvent
                    return -d3.event.deltaY * (d3.event.deltaMode === 1 ? 0.25 : d3.event.deltaMode ? 1 : 0.01);
                })
                .on("zoom", function() {
                    g_curTransform = d3.event.transform;
                    Layout();
                })
            );

        g_joined_links = g_links_group.selectAll("line")
          .data(g_data.links)
          .join("line");

        // map node counts to a node size
        const minNodeWeight = d3.min(g_data.nodes, function (node) {
            return node.size;
        });
        const maxNodeWeight = d3.max(g_data.nodes, function (node) {
            return node.size;
        });

        var nodeScale = d3.scaleLinear()
            .domain([minNodeWeight, maxNodeWeight])
            .range([4, 20])
            .clamp(true);

        g_joined_nodes = g_nodes_group.selectAll("circle")
          .data(g_data.nodes)
          .join("circle")
            .attr("r", function (node) {
                return nodeScale(node.size);
            })
            .attr("fill", function (node) {
                return g_scale(node.type);
            })
            .call(d3.drag()
                .on("start", function (node) {
                    if (!d3.event.active)
                        g_simulation.alphaTarget(0.3).restart();
                    node.fx = node.x;
                    node.fy = node.y;
                })
                .on("drag", function (node) {
                    // map SVG coord system back to model coord system
                    node.fx += d3.event.dx / g_curZoom;
                    node.fy += d3.event.dy / g_curZoom;
                })
                .on("end", function (node) {
                    if (!d3.event.active)
                        g_simulation.alphaTarget(0);
                    node.fx = null;
                    node.fy = null;
                })
            );

        g_joined_labels = g_nodes_group.selectAll("text")
          .data(g_data.nodes)
          .join("text")
            .text(function (d) {
                return d.title;
            })
            .attr("x", function (node) {
                return nodeScale(node.size);
            });
    }


    function DoSimulation() {
        g_simulation = d3.forceSimulation(g_data.nodes)
            .force("link", d3.forceLink(g_data.links)
                .id(function (node) {
                    return node.title;
                })
                .distance(50)
            )
            .force("charge", d3.forceManyBody())
            .force("center", d3.forceCenter(GetWindowWidth() / 2, GetWindowHeight() / 2))
            .on("tick", Layout);
        }

    
    function CreateChart(title, json_text) {
        g_data = JSON.parse(json_text);
        g_title_text = title;
        DoCreateChart();
        DoSimulation();
    }


    //----------------------------------------------------------
    function DoSetSelection() {
        g_joined_nodes.transition(250)
            .attr("opacity", function (node) {
                return GetNodeOpacity(node.event_id);
            })

        g_joined_labels.transition(250)
            .attr("opacity", function (node) {
                return GetNodeOpacity(node.event_id);
            })

        g_joined_links.transition(250)
            .attr("opacity", function (node) {
                return GetLinkOpacity(node.event_id);
            })
    }


    function SetSelection(json_text) {
        selection = JSON.parse(json_text);

        g_selected_nodes = new Set();
        selection.nodes.forEach(function (event_id) {
            g_selected_nodes.add(event_id);
        });

        g_selected_links = new Set();
        selection.links.forEach(function (event_id) {
            g_selected_links.add(event_id);
        });

        g_has_selection = g_selected_nodes.size != 0 || g_selected_links.size != 0;

        DoSetSelection();
    }


</script>