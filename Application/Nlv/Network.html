<!--
Copyright (C) Niel Clausen 2020. All rights reserved.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program. If not, see <https://www.gnu.org/licenses/>.
-->
<!DOCTYPE html>
<meta charset="utf-8">

<!-- Load d3.js -->
<script src="polyfill.8.1.3.js"></script>
<script src="fetch.umd.3.0.0.js"></script>
<script src="d3.v5.min.js"></script>

<!-- Create a div where the graph will take place -->
<div id="my_dataviz"></div>


<style>
    .links line {
        stroke: #aaa;
    }

    .nodes circle {
        stroke: #fff;
        stroke-width: 1.5px;
        pointer-events: all;
    }

    .nodes text {
        font-family: sans-serif;
        font-size: x-small;
        pointer-events: none;
    }
</style>


<script>
    //----------------------------------------------------------
    var g_node_id = 0

    function SetNodeId(node_id) {
        g_node_id = node_id;
    }


    //----------------------------------------------------------

    // retained data
    var g_data = null;
    var g_title_text = null;

    // append the svg object to the body of the page
    var g_svg = d3.select("#my_dataviz").append("svg");

    var g_links_group = g_svg.append("g")
        .attr("class", "links");

    var g_nodes_group = g_svg.append("g")
        .attr("class", "nodes");

    const g_scale = d3.scaleOrdinal(d3.schemeCategory10);


    //----------------------------------------------------------
    function DrawChart(switch_time) {
        // set the dimensions and margins of the graph
        const min_window = 300, margin = 30;
        const window_width = Math.max(min_window, document.documentElement.clientWidth);
        const window_height = Math.max(min_window, document.documentElement.clientHeight);

        // reference for zoom transitions
        const ref_transition = d3.transition()
            .duration(switch_time);

        var curTransform = d3.zoomIdentity;
        var curZoom = curTransform.k;

        g_svg
            .attr("width", window_width - margin)
            .attr("height", window_height - margin)
            .call(d3.zoom()
                .scaleExtent([1, 8])
                .wheelDelta(function wheelDelta() {
                    // d3.event here is the underlying WheelEvent
                    return -d3.event.deltaY * (d3.event.deltaMode === 1 ? 0.25 : d3.event.deltaMode ? 1 : 0.01);
                })
                .on("zoom", function() {
                    curTransform = d3.event.transform;
                    Layout();
                })
            );

        var links = g_links_group.selectAll("line")
          .data(g_data.links)
          .join("line");

        // map node counts to a node size
        const minNodeWeight = d3.min(g_data.nodes, function (node) {
            return node.size;
        });
        const maxNodeWeight = d3.max(g_data.nodes, function (node) {
            return node.size;
        });

        var nodeScale = d3.scaleLinear()
            .domain([minNodeWeight, maxNodeWeight])
            .range([4, 20])
            .clamp(true);

        var nodes = g_nodes_group.selectAll("circle")
          .data(g_data.nodes)
          .join("circle")
            .attr("r", function (node) {
                return nodeScale(node.size);
            })
            .attr("fill", function (node) {
                return g_scale(node.type);
            })
            .call(d3.drag()
                .on("start", function (node) {
                    if (!d3.event.active)
                        simulation.alphaTarget(0.3).restart();
                    node.fx = node.x;
                    node.fy = node.y;
                })
                .on("drag", function (node) {
                    // map SVG coord system back to model coord system
                    node.fx += d3.event.dx / curZoom;
                    node.fy += d3.event.dy / curZoom;
                })
                .on("end", function (node) {
                    if (!d3.event.active)
                        simulation.alphaTarget(0);
                    node.fx = null;
                    node.fy = null;
                })
            );

        var labels = g_nodes_group.selectAll("text")
          .data(g_data.nodes)
          .join("text")
            .text(function (d) {
                return d.title;
            })
            .attr("x", function (node) {
                return nodeScale(node.size);
            });

        var simulation = d3.forceSimulation(g_data.nodes)
            .force("link", d3.forceLink(g_data.links)
                .id(function (node) {
                    return node.title;
                })
                .distance(50)
            )
            .force("charge", d3.forceManyBody())
            .force("center", d3.forceCenter(window_width / 2, window_height / 2))
            .on("tick", Layout);
            
        
        function Layout() {
            const doTransition = (curZoom != curTransform.k);
            curZoom = curTransform.k;

            const ref_transition = d3.transition()
                .duration(250);

            (doTransition ? links.transition(ref_transition) : links)
                // map model coord system to SVG coord system
                .attr("x1", function (link) {
                    return curTransform.applyX(link.source.x);
                })
                .attr("y1", function (link) {
                    return curTransform.applyY(link.source.y);
                })
                .attr("x2", function (link) {
                    return curTransform.applyX(link.target.x);
                })
                .attr("y2", function (link) {
                    return curTransform.applyY(link.target.y);
                });

            function translate(item) {
                // map model coord system to SVG coord system
                const x = curTransform.applyX(item.x);
                const y = curTransform.applyY(item.y);
                return "translate(" + x + "," + y + ")";
            }

            (doTransition ? nodes.transition(ref_transition) : nodes)
                .attr("transform", translate);

            (doTransition ? labels.transition(ref_transition) : labels)
                .attr("transform", translate);
        }
    }

    
    function CreateChart(title, json_text, switch_time) {
        g_data = JSON.parse(json_text);
        g_title_text = title;
        DrawChart(switch_time);
    }


    //----------------------------------------------------------
    function OnResize() {
        if (g_data !== null) {
            DrawChart(0);
        }
    }

//    window.addEventListener("resize", OnResize);

</script>